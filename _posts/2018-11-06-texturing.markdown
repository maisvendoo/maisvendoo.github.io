---
layout: post
title:  "Введение в OpenSceneGraph: Основы работы с текстурами"
date:   2018-11-06 16:02:00 +0300
categories: jekyll update
---

Мы уже рассматривали пример, где раскрашивали квадрат во все цвета радуги. Тем не менее существует и другая технология, а именно применение к трехмерной геометрии так называемой *текстурной карты* или просто текстуры - растрового двухмерного изображения. При этом воздействие оказывается не на вершины геометрии, а изменяются данные всех пикселей, получаемых при растеризации сцены. Такой прием позволяет существенно увеличить реалистичность и детальность конечного изображения.

OSG поддерживает несколько текстурных атрибутов и режимов текстурирования. Но, перед тем как говорить о текстурах, поговорим о том, как в OSG оперируют с растровыми изображениями. Для работы с растровыми изображениями предусмотрен специальный класс - osg::Image, хранящий внутри себя данные изображения, предназначенных, в конечном итоге, для текстурирования объекта.

## Представление данных растровых изображений. Класс osg::Image

Лучшим способом загрузки изображения с диска служит применение вызова osgDB::readImageFile(). Оно очень похож на уже набившbq нам оскомину вызов osg::readNodeFile(). Если у нас есть битмэп с именем picture.bmp, то есго загрузка будет выглядеть так

```cpp
osg::ref_ptr<osg::Image> image = osgDB::readImageFile("picture.bmp");
```

Если изображение загружено корректно, то указатель будет валидным, в противном случае функция возвратит NULL. После загрузки мы можем получить информацию об изображении, используя следующие публичные методы

1. s(), t() и r() - вовращают ширину, высоту и глубину изображения.
2. data() - возвращает указатель типа unsigned char* на "сырые" данные изображения. Через данный указатель разработчик может непосредственно воздействовать на данные изображения. Получить представление о формате данных изображения можно, используя методы getPixalFormat() и getDataType(). Возващаемые ими значения эквивалентны параметрам формата и типа функций OpenGL glTexImage*(). Например, если картинка имеет формат пикселя GL_RGB и тип данный GL_UNSIGNED_BYTE то используются три независимых элемена (беззнаковых байта) для представления RGB-компонент цвета

![](https://habrastorage.org/webt/6g/mo/or/6gmoorwfvryg44pq7sdi0cb4l9s.png)

Можно создать новый объект изображения и выделить под него память

```cpp
osg::ref_ptr<osg::Image> image = new osg::Image;
image->allocateImage(s, t, r, GL_RGB, GL_UNSIGNED_BYTE);
unsigned char *ptr = image->data();
// Далее выполняем с буфером данных изображения любые операции 
```

Здесь s, t, r - размеры изображения; GL_RGB задает формат пикселя, а GL_UNSIGNED_BYTE - тип данных для описания одной цветовой компоненты. Внетренний буфер данных нужного размера выделяется в памяти и автоматически уничтожается, если на данное изображение нет ни одной ссылки.

Система плагинов OSG поддерживает загрузку чуть ли не всех популярных форматов изобаржений: *.jpg, *.bmp, *.png, *.tif и так далее. Этот список нетрудно расширить, написав собственный плагин, но это тема для отдельной беседы.

## Основы текстурирования

Для наложения текстуры на трехмерную модель необходимо выполнить ряд шагов:

1. Задать геометрическому объекту текстурные координаты вершин (в среде трехмерных дизайнеров это называется UV-разверткой).
2. Создать объект атрибута текстуры для 1D, 2D, 3D или  кубической текстуры.
3. Задать одно или несколько изображения для атрибута текстуры.
4. Прикрепить текстурный атрибут и режим к набору состояний, прменяемому к отрисовываемому объекту.

OSG определяет класс osg::Texture, инкапсулирующий все виды текстур. От него производятся подклассы osg::Texture1D, osg::Texture2D, osg::Texture3D и osg::TextureCubeMap, которые представляю различные техники текстурирования, принятые в OpenGL.

Наиболее употребимый метод класса osg::Texture это setImage(), задающий изображение, используемое в текстуре, например

