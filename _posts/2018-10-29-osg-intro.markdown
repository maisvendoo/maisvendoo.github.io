---
layout: post
title:  "Введение в OpenSceneGraph: Наша первая программа"
date:   2018-10-29 09:19:00 +0300
categories: jekyll update
---

Знакомство с графическим движком OpenSceneGraph начнем с простейшего примера, как это обычно принято в программировании с некоего "Hello world!". Напишем такой код в файле main.h

```cpp
#ifndef		MAIN_H
#define		MAIN_H

#include	<osgDB/ReadFile>
#include	<osgViewer/Viewer>

#endif
```

Далее реализуем основное тело программы в файле main.cpp

```cpp
#include    "main.h"

int main(int argc, char *argv[])
{
    (void) argc;
    (void) argv;

    osg::ref_ptr<osg::Node> root = osgDB::readNodeFile("../data/cessna.osg");
    osgViewer::Viewer viewer;
    viewer.setSceneData(root.get());

    return viewer.run();
}
```

После компиляции и запуска мы получим что-то вроде этого

![](https://habrastorage.org/webt/zy/e8/yn/zye8ynsswiqzhlebo_4-hxmdm4c.png)

В данном примере мы представляем два новых класса: osg::ref_ptr<> и osg::Node. Класс osg::Node представляет собой базовый элемент графа сцены. Переменная root обозначает корневой узел (ноду) для модели самолета, которая используется для визуализации данных сцены.

Между тем, класс osg::ref_ptr<> представляет собой шаблонный класс, созданный для управления объектом корневой ноды. Это так называемый "умный" указатель, который предоставляет дополнительные возможности для эффективного управления памятью в программе.

## Понятие об управлении памятью в OSG

В типичном варианте, разработчик должен создать указатель на корневую ноду, которая непосредственно, или опосредованно, управляет всеми дочерними нодами графа сцены. В этом случае, при манипуляциях с графом сцены, и, например, удалением некоторых его узлов нужно внимательно следить, чтобы удаленные узлы графа более не отрисовывались. Этот процесс всегда сопровождается ошибками, трудоемкой отладкой, так ка разработчику довольно трудно отследить какие указатели на объекты ссылаются на существующие данные, а какие должны быть удалены. Без эффективного управления памятью велика вероятность возникновения ошибок сегментации и утечек памяти.

Управление памятью является критически важной задачей в OSG и его концепция базируется на двух тезисах:

1. Выделение памяти: обеспечение выделения нужного для хранения объекта объема памяти.
2. Освобождение памяти: Возврат выделенной памяти системе, в тот момент когда в ней нет необходимости.

Многие современные языки программирования, такие как C#, Java и Visual Basic используют так называемый сборщик мусора для освобождения выделенной памяти. В основном это реализуется подсчетом объектов, ссылающихся на данную область памяти, и освобождение указанного блока памяти, когда число ссылок становится равно нулю.

Концепция языка C++ Не предусматривает подобного подхода, однако мы можем имитировать её путем использования так называемых "умных" указателей.

## Классы ref_ptr<> и Referenced

К счастью в OSG обеспечивается собственный механизм умных указателей на основе класса osg::ref_ptr<>, для реализации автоматической сборки мусора. Для его правильной работы OSG предоставляет ещё один класс osg::Referenced для управления блоками памяти, для которых осуществляется подсчет ссылок на них.

Класс osg::ref_ptr<> предоставляет несколько операторов и методов.

* get() - публичный метод возвращающий "сырой" указатель, например, при использовании в качестве аргумента шаблона osg::Node данный метод вернет osg::Node*.
* operator*() - фактически оператор разыменования.
* operator->() и operator=() - позволяют использовать osg::ref_ptr<> как классический указатель при доступе к методам и свойствам объектов, описываемых данным указателем.
* operator==(), operator!=() и operator!() - ползоляют выполнять над умными указателями операции сравнения.
* valid() - публичный метод, возвращающий истину, если управляемый указатель имеет корректное значение (не NULL). Выражение some_ptr.valid() эквивалентно выражению some_ptr != NULL, если some_ptr - умный указатель.
* release() - публичный метод, полезен, когда требуется возвратить управляемый адрес из функци. Про него будет подробнее рассказано позже.

Класс osg::Referenced является базовым классом для всех элементов графа сцены, таких как ноды, геометрия, состояния рендеринга и другие объекты, размещаемые на сцене. Таким образом, создавая корневой узел сцены, мы косвенно наследуем весь функционал, предоставляемый классом osg::Referenced. Поэтому в нашей программе присутсвует объявление

```cpp
osg::ref_ptr<osg::Node> root;
```

Класс osg::Referenced содержит целочисленный счетчик ссылок на выделенный блок памяти. Этот счетчик инициализируется нулем в конструкторе класса. Он увеличивается на единицу, когда создается объект osg::ref_ptr<>. Этот счетчик уменьшается, как только удаляется какая-лиюо ссылка на объект, описываемый данным указателем. Объект автоматически уничтожается, когда на него перестают ссылаться какие-либо умные указатели.

Класс osg::Referenced имеет три основных метода:

* ref() - публичный метод, увеличивающий на 1 счетчик ссылок.
* unref() - публичный метода, уменьшающий на 1 счетчик ссылок.
* referenceCount() - публичный метод, возвращающий текущее значение счетчика ссылок, что бывает полезно при отладке кода.

Эти методы доступный во всех классах, производных от osg::Referenced. Однако, следует помнить о том, что ручное управление счетчиком ссылок может привести к непредсказуемым последствиям, и пользуясь этим следует четко представлять себе что вы делаете.

