---
layout: post
title:  "Введение в OpenSceneGraph: Наша первая программа"
date:   2018-10-29 09:19:00 +0300
categories: jekyll update
---

Знакомство с графическим движком OpenSceneGraph начнем с простейшего примера, как это обычно принято в программировании с некоего "Hello world!". Напишем такой код в файле main.h

```cpp
#ifndef		MAIN_H
#define		MAIN_H

#include	<osgDB/ReadFile>
#include	<osgViewer/Viewer>

#endif
```

Далее реализуем основное тело программы в файле main.cpp

```cpp
#include    "main.h"

int main(int argc, char *argv[])
{
    (void) argc;
    (void) argv;

    osg::ref_ptr<osg::Node> root = osgDB::readNodeFile("../data/cessna.osg");
    osgViewer::Viewer viewer;
    viewer.setSceneData(root.get());

    return viewer.run();
}
```

После компиляции и запуска мы получим что-то вроде этого

![](https://habrastorage.org/webt/zy/e8/yn/zye8ynsswiqzhlebo_4-hxmdm4c.png)

В данном примере мы представляем два новых класса: osg::ref_ptr<> и osg::Node. Класс osg::Node представляет собой базовый элемент графа сцены. Переменная root обозначает корневой узел (ноду) для модели самолета, которая используется для визуализации данных сцены.

Между тем, класс osg::ref_ptr<> представляет собой шаблонный класс, созданный для управления объектом корневой ноды. Это так называемый "умный" указатель, который предоставляет дополнительные возможности для эффективного управления памятью в программе.

## Понятие об управлении памятью в OSG

В типичном варианте, разработчик должен создать указатель на корневую ноду, которая непосредственно, или опосредованно, управляет всеми дочерними нодами графа сцены. В этом случае, при манипуляциях с графом сцены, и, например, удалением некоторых его узлов нужно внимательно следить, чтобы удаленные узлы графа более не отрисовывались. Этот процесс всегда сопровождается ошибками, трудоемкой отладкой, так ка разработчику довольно трудно отследить какие указатели на объекты ссылаются на существующие данные, а какие должны быть удалены. Без эффективного управления памятью велика вероятность возникновения ошибок сегментации и утечек памяти.

Управление памятью является критически важной задачей в OSG и его концепция базируется на двух тезисах:

1. Выделение памяти: обеспечение выделения нужного для хранения объекта объема памяти.
2. Освобождение памяти: Возврат выделенной памяти системе, в тот момент когда в ней нет необходимости.

Многие современные языки программирования, такие как C#, Java и Visual Basic используют так называемый сборщик мусора для освобождения выделенной памяти. В основном это реализуется подсчетом объектов, ссылающихся на данную область памяти, и освобождение указанного блока памяти, когда число ссылок становится равно нулю.

Концепция языка C++ Не предусматривает подобного подхода, однако мы можем имитировать её путем использования так называемых "умных" указателей.

