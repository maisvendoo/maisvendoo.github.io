---
layout: post
title:  "Введение в OpenSceneGraph: Умные указатели"
date:   2018-10-29 14:00:00 +0300
categories: jekyll update
---

## Понятие об управлении памятью в OSG

В типичном варианте, разработчик должен создать указатель на корневую ноду, которая непосредственно, или опосредованно, управляет всеми дочерними нодами графа сцены. В этом случае, при манипуляциях с графом сцены, и, например, удалением некоторых его узлов нужно внимательно следить, чтобы удаленные узлы графа более не отрисовывались. Этот процесс всегда сопровождается ошибками, трудоемкой отладкой, так ка разработчику довольно трудно отследить какие указатели на объекты ссылаются на существующие данные, а какие должны быть удалены. Без эффективного управления памятью велика вероятность возникновения ошибок сегментации и утечек памяти.

Управление памятью является критически важной задачей в OSG и его концепция базируется на двух тезисах:

1. Выделение памяти: обеспечение выделения нужного для хранения объекта объема памяти.
2. Освобождение памяти: Возврат выделенной памяти системе, в тот момент когда в ней нет необходимости.

Многие современные языки программирования, такие как C#, Java и Visual Basic используют так называемый сборщик мусора для освобождения выделенной памяти. В основном это реализуется подсчетом объектов, ссылающихся на данную область памяти, и освобождение указанного блока памяти, когда число ссылок становится равно нулю.

Концепция языка C++ Не предусматривает подобного подхода, однако мы можем имитировать её путем использования так называемых "умных" указателей.

## Классы ref_ptr<> и Referenced

К счастью в OSG обеспечивается собственный механизм умных указателей на основе класса osg::ref_ptr<>, для реализации автоматической сборки мусора. Для его правильной работы OSG предоставляет ещё один класс osg::Referenced для управления блоками памяти, для которых осуществляется подсчет ссылок на них.

Класс osg::ref_ptr<> предоставляет несколько операторов и методов.

* get() - публичный метод возвращающий "сырой" указатель, например, при использовании в качестве аргумента шаблона osg::Node данный метод вернет osg::Node*.
* operator*() - фактически оператор разыменования.
* operator->() и operator=() - позволяют использовать osg::ref_ptr<> как классический указатель при доступе к методам и свойствам объектов, описываемых данным указателем.
* operator==(), operator!=() и operator!() - ползоляют выполнять над умными указателями операции сравнения.
* valid() - публичный метод, возвращающий истину, если управляемый указатель имеет корректное значение (не NULL). Выражение some_ptr.valid() эквивалентно выражению some_ptr != NULL, если some_ptr - умный указатель.
* release() - публичный метод, полезен, когда требуется возвратить управляемый адрес из функци. Про него будет подробнее рассказано позже.

Класс osg::Referenced является базовым классом для всех элементов графа сцены, таких как ноды, геометрия, состояния рендеринга и другие объекты, размещаемые на сцене. Таким образом, создавая корневой узел сцены, мы косвенно наследуем весь функционал, предоставляемый классом osg::Referenced. Поэтому в нашей программе присутсвует объявление

```cpp
osg::ref_ptr<osg::Node> root;
```

Класс osg::Referenced содержит целочисленный счетчик ссылок на выделенный блок памяти. Этот счетчик инициализируется нулем в конструкторе класса. Он увеличивается на единицу, когда создается объект osg::ref_ptr<>. Этот счетчик уменьшается, как только удаляется какая-лиюо ссылка на объект, описываемый данным указателем. Объект автоматически уничтожается, когда на него перестают ссылаться какие-либо умные указатели.

Класс osg::Referenced имеет три основных метода:

* ref() - публичный метод, увеличивающий на 1 счетчик ссылок.
* unref() - публичный метода, уменьшающий на 1 счетчик ссылок.
* referenceCount() - публичный метод, возвращающий текущее значение счетчика ссылок, что бывает полезно при отладке кода.

Эти методы доступный во всех классах, производных от osg::Referenced. Однако, следует помнить о том, что ручное управление счетчиком ссылок может привести к непредсказуемым последствиям, и пользуясь этим следует четко представлять себе что вы делаете.

## Сборка мусора: как и почему?

Существуют несколько причин, по которым следует использовать умные указатели и уборку мусора:

* Минимизация критических ошибок: использование умных указателей позволяет автоматизировать выделение и освобождение памяти. Отсутствуют опасные "сырые" указатели.
* Эффективное управление памятью: память, выделенная под объект освобождается сразу, как только объект становится не нужен, что ведет к экономному использованию ресурсов системы.
* Облегчение отладки приложения: имея возможность четко отслеживать число ссылок на объект, мы имеем возможности для разного рода оптимизаций и экспериментов.

Допустим, что граф сцены состоит из корневой ноды и нескольких уровней дочерних узлов. Если корневая нода и все дочерние ноды управляются с использованием класса osg::ref_ptr<>, то приложение может отслеживать только указатель на корневую ноду. Удаление этой ноды приведет к последовательному, автоматическому удалению всех дочерних узлов.

![](https://habrastorage.org/webt/5r/az/ri/5razrigi8nvg-75jwcm4vhhurda.png)

Умные указатели могут использоваться как локальные переменные, глобальные переменные, члены классов и автоматически уменьшают счетчик ссылок, при выходе умного указателя за пределы области видимости. 

Умные указатели настоятельно рекомендуются разработчиками OSG к использованию в проектах, однако есть несколько принципиальных моментов, на которые следует обратить внимание:

* Экземпляры osg::Referenced и его производных могут быть созданы исключительно на куче. Они не могут быть созаны на стеке как локальные переменные, так как деструкторы этих классов объявлены как proteced. Например
```cpp
osg::ref_ptr<osg::Node> node = new osg::Node; // правильно
osg::Node node; // неправильно
```
* Можно создавать временные узлы сцены используя и обычные указатели C++, однако такой подход будет небезопасным. Лучше применять умные указатели, гарантирующие корректное управление графом сцены
```cpp
osg::Node *tmpNode = new osg::Node; // в принципе, будет работать...
osg::ref_ptr<osg::Node> node = tmpNode; // но лучше завершить работу с временным указателем таким образом!
``` 
* Ни в коем случае не стоит использовать в дереве сцены циклических ссылок, когда узел ссылается сам на себя непосредствеено или косвенно через несколько уровней 

![](https://habrastorage.org/webt/ds/af/er/dsafertsy4m2doboaeb9cgjdzyk.png)