---
layout: post
title:  "Введение в OpenSceneGraph: Рендеринг в текстуру"
date:   2018-11-07 15:20:00 +0300
categories: jekyll update
---

Техника рендеринга в текстуру позволяет разработчику создать текстуру, основанную на некоторой трехмерной подсцене или модели и применить её к поверхности на основной сцене. Подобную технологию часто называют "запеканием" текстуры.

Для динамического запекания текстуры необходимо выполнить три шага:

1. Создать объект текстуры для рендеринга в неё.
2. Отрендерить сцену в текстуру.
3. Использовать полученную текстуру по назначению.

Мы должны создать пустой текстурный объект. OSG позволяет сосздать пустую текстуру заданного размера. Метод setTextureSize() позволяет задавать ширину и высоту текстуры, а так же ещё глубину в качестве дополнительного параметра (для 3D-текстур).

Для выполнения рендеринга в текстуру её следует присоединить к объекту камеры путем вызова метода attach(), принимающего в качестве аргумента объект текстуры. Кроме того данный метод принимает аргрумент, указывающий, какую часть буфера кадра следует рендерить в данную текстуру. Например, для передачи буфера цвета в текстуру следует выполнить следующий код

```cpp
camera->attach( osg::Camera::COLOR_BUFFER, texture.get() );
```

К другим, доступным для рендеринга частям кадрового буфера, относятся буфер глубины DEPTH_BUFFER, буфер трафарета STENCIL_BUFFER дополнительные буферы цвета от COLOR_BUFFER0 до COLOR_BUFFER15. Наличие дополнительных буферов цвета и их количество определяется моделью видеокарты.

Кроме того, для камеры, выполняющей рендеринг в текстуру следует установить параметры матрицы проекции и вьюпорта, размер которого соотвествует размеру текстуры. Текстура будет обновлятся в процессе прорисовки каждого кадра. Необходимо учитывать, что основная камера не должна использоваться для рендеринга в текстуру, так как она обеспечивает рендеринг основной сцены и вы просто получите черный экран. Это требование может не выполнятся только тогда, когда вы выполняете внеэкранный рендеринг.

## Буфер кадра, пиксельный буфер и FBO

Проблема данной задачи в том, что необходим способ получения визуального представления буфера кадра и передача его в объект текстуры. Прямой подход к её решению заключается в использовании функций glReadPixels() для возврата пикселей из буферов кадра и применение результата в функции glTexImage* (). Это довольно простая операция, но она всегда будет выполнятся крайне медленно.

В плане повышения эффективности лучше использовать функцию glCopyTexSubImage(). Однако и этот способ оставляет ресурс для оптимизации. Хорошей идеей является рендеринг сцены напрямую в текстурый буфер изображения, не прибегая к копированию данных из буфера кадра. Для этого существует два основных решения:

1. Буфер для хранения данных о пикселях, с дескриптором формата пикселя, эквивалентный окну. Должен быть уничтоден по окончании рендеринга.
2. Объект буфера кадра (FBO), который иногда лучше пиксельного буфера в том смысле что позволяет добавлять буферы кадра и перенаправлять вывод на себя.

OSG поддерживает разные конечные точки рендеринга: прямой рендеринг в кадровый буфер (FRAME_BUFFER), пиксельный буфер (PIXEL_BUFFER) и FBO (FRAME_BUFFER_OBJECT). Класс osg::Camera предоставляет метод setRenderTargetImplementation() для задания цели рендеринга, например

```cpp
camera->setRenderTargetImplementation(osg::Camera::FRAME_BUFFER);
```

## Пример реализации рендеринга в текстуру



![](https://habrastorage.org/webt/se/g1/jr/seg1jrflbtmzfkb5cbtwys1hleg.gif)

